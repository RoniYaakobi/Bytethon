# Other documentation

This is another developer documentation page, this has the same guidelines as the [`functions.md`](functions.md) page.
___

## Structs
Other than the structs in `utils.h`, this project uses 3 main structs:
- `Memory` → Stores everything memory related: blocks, bytes, pointers etc...
- `Block` → Stores data about individual memory blocks
- `Command` → Stores data about comands.

Also documentation for the `HashMap` struct is in [utils.md](utils.md)
___

### `Memory`
This struct contains the following data:
- `.*p_bytes` → `uint8_t` array, stores the raw bytes.
- `.*p_blocks` → `Block` array, each `Block` stores the metadata for the `p_bytes` array.
- `.amount_of_blocks` → `size_t`, how many blocks are there in the `p_blocks` array
- `.memory_size` → `size_t`, stores the metadata for the `p_bytes` array.
- `.*p_pointers` → `HashMap*`, stores the pointers to blocks in the array
- `.on_heap` → `uint8_t`, stores a boolean for whether or not the struct was created via `malloc()`

The `Memory` struct is used for almost every operation in the `simulation`. If you want to make a pointer, it is stored in `*p_pointers` hashmap. If you want to allocate memory, it gets the pointer from the hashmap `*p_pointers`, and creates a new block in the `p_blocks` array, which represents a section of the `p_bytes` array.

The `p_bytes` array is of type `uint8_t`, as each index is the size of a byte.
___

### `Block`
This struct contains the following data:
- `.size` → `size_t` , what size is the current block.
- `.start_index` → `size_t`, a pointer to the index in the `bytes` array which corresponds to the start of the block.
- `.p_next` → `Block*`, pointer to the next block in the linked list.
- `.p_prev` → `Block*`, pointer to the previous block in the linked list.
- `.free` → `uint8_t`, indicates whether the block is free (1 = free, 0 = allocated).
- `.uninitialized` → `uint8_t`, indicates whether the block is free (1 = uninitialized, 0 = initialized).

The idea behind `size` is that using `index + size` you can compute the start of the next block, effectively meaning that the length of the block goes from `index` to `index + size - 1`.

`p_next` and `p_prev` are for a doubly linked list. Allows future expansion into a dynamic linked list, removing the fixed array size limitation and enabling larger memory allocations. This currently limits the memory because the array for both the bytes and the blocks are initialized to the same size, and `Block` struct is a lot larger than `uint8_t`. This issue will be covered more in depth elsewhere, likely in issues on the github website.

If a block is free, it can be merged with other free blocks (and obviously the searching algorithm for `malloc()` can't allocate a previously allocated block).

If a block is uninitialized, it has been allocated, and in this case it holds garbage values that the user didn't create. This means that when command `>>> set_val` is used, it initializes the block. This is more of a visualization thing than a practicality, but as this is a simulation, the user needs to understand that they need to first set a value to the block, and only then access it.

___

### `Command`
This struct stores metadata and function pointers for commands within the system.

- `.*p_name` → a string, a pointer to the name which is the description of the command.
- `.*p_description` → a string , a pointer to a string which is the description of the command.
- `.*union func` →  a function pointer stored as a union of different function pointer types. Will be used for future expansion of the create_cmds function (which will eventually be generated by a script).
- `.amount_of_arguments` → `size_t`, stores how many arguments the command takes.
- `.type_of_function` → `Command_Classification`, an enum that represents the type of the function. Enums definitions below.
___

## Enums
There are a few types of enums in this project, all for different aspects of the program.
___

### `Command_Classification`
`ALL` = 0
`Memory_management` = 1
`Command_management` = 2

These values determine the type of command being executed, allowing the dispatcher to process the function appropriately.

`ALL` means that the function needs both memory and commands hashmap structs.
`Memory_management` means that it only needs the memory struct.
`Command_management` means that it only needs the commands hashmap struct.
___

## Macros
Macros generally act as constants between modules, or within a module.

___

### MAX_SIZE_STACK
The max size of the `blocks` array on the stack, allows up to 512 kb of allocated memory for the stack only from the `blocks` array.

### MAX_SIZE_HEAP
The max size of the `blocks` array on the heap, allows up to 512 mb of allocated memory for the heap only from the `blocks` array.

### AMOUNT_OF_CMDS
Amount of commands that have been added. This macro may be removed in the future, as the `init_commands` function may become an automatically generated file. This will be done via python script each time a new command is added, in order to remove human error, like forgeting to update the amount of commands in the macro.

### MAX_INPUT_SIZE
Size of user input buffer. No current safeguard for if the user input exceeds this length.

___

## Other typedefs
There are other typedefs for things needed in specific cases

___

### Command_Func
A generic function pointer which can accept an int and a character double pointer, used to store the function pointer in the Command struct.


### Memo_Command_Func
A function pointer type that takes a `Memory*`, an `int`, and a `char**`, used for memory-related commands.


### Hashmap_Command_Func
A function pointer type that takes a `Hashmap*`, an `int`, and a `char**`, used for Commands-related commands.


### ALL
A function pointer type that takes a `Memory*`, a `Hashmap*`, an `int`, and a `char**`, used for memory-related commands. All as it needs all the structs, which currently is only `Memory*` and `Hashmap*`.